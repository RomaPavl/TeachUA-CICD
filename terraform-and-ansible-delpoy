pipeline {
    agent any

    environment {
        TERRAFORM_DIR = './terraform/azure'
        INVENTORY_FILE = './ansible/inventory/hosts.ini'
        TFVARS_FILE = 'config.auto.tfvars.json'
        TFPLAN_JSON = './terraform/azure/tfplan.json'
    }
    
    stages {
        stage('Prepare tfvars with secrets') {
            steps {
                withCredentials([
                    string(credentialsId: 'datasource-pass', variable: 'DB_PASSWORD'),
                    string(credentialsId: 'ssh_public_key', variable: 'SSH_PUB_KEY'),
                    string(credentialsId: 'location', variable: 'LOCATION'),
                    string(credentialsId: 'resource_group_name', variable: 'RESOURCE_GROUP'),
                    string(credentialsId: 'admin_username', variable: 'ADMIN_USERNAME'),
                    string(credentialsId: 'backend_name', variable: 'BACKEND_NAME'),
                    string(credentialsId: 'monitoring_name', variable: 'MONITORING_NAME'),
                    string(credentialsId: 'frontend_name', variable: 'FRONTEND_NAME'),
                    string(credentialsId: 'key_vault_name', variable: 'KEY_VAULT_NAME'),
                    string(credentialsId: 'postgres_server_name', variable: 'POSTGRES_SERVER_NAME'),
                    string(credentialsId: 'postgres_db_name', variable: 'POSTGRES_DB_NAME'),
                    string(credentialsId: 'postgres_admin_user', variable: 'POSTGRES_ADMIN_USER'),
                    string(credentialsId: 'postgres_admin_password', variable: 'POSTGRES_ADMIN_PASSWORD'),
                    string(credentialsId: 'clientId', variable: 'TF_CLIENT_ID'),
                    string(credentialsId: 'clientSecret', variable: 'TF_CLIENT_SECRET'),
                    string(credentialsId: 'tenant_id', variable: 'TF_TENANT_ID'),
                    string(credentialsId: 'subscription_id', variable: 'TF_SUBSCRIPTION_ID')
          // додай інші секрети по потребі
        ]) {
            script {
            // Створюємо JSON файл для tfvars
            def tfvarsContent = """
            {
                "location": "${LOCATION}",
                "resource_group_name": "${RESOURCE_GROUP}",
                'admin_username': "${ADMIN_USERNAME}",
                "ssh_public_key": "${SSH_PUB_KEY}",
                "db_password": "${DB_PASSWORD}",
                "frontend_name": "${FRONTEND_NAME}",
                "backend_name": "${BACKEND_NAME}",
                "monitoring_name": "${MONITORING_NAME}",
                "key_vault_name": "${KEY_VAULT_NAME}",
                "postgres_server_name": "${POSTGRES_SERVER_NAME}",
                "postgres_db_name": "${POSTGRES_DB_NAME}",
                "postgres_admin_user": "${POSTGRES_ADMIN_USER}",
                "postgres_admin_password": "${POSTGRES_ADMIN_PASSWORD}",
                "client_id": "${TF_CLIENT_ID}",
                "client_secret": "${TF_CLIENT_SECRET}",
                "tenant_id": "${TF_TENANT_ID}",
                "subscription_id": "${TF_SUBSCRIPTION_ID}"
            }
            """
            writeFile file: env.TFVARS_FILE, text: tfvarsContent
          }
         }
       }
     }
        stage('Terraform Init & Plan') {
            steps {
                dir("${env.TERRAFORM_DIR}") {
                    bat 'terraform init'
                    bat 'terraform plan -out=tfplan'
                    bat 'terraform show -json tfplan > tfplan.json'
                }
            }
        }

        stage('Terraform Apply if Changes') {
            steps {
                script {
                    def planJson = readFile(env.TFPLAN_JSON)
                    def hasChanges = !planJson.contains('"resource_changes":[]')

                    if (hasChanges) {
                        echo "✅ Зміни виявлено — застосовуємо Terraform"
                        bat "cd ${env.TERRAFORM_DIR} && terraform apply -auto-approve tfplan"
                    } else {
                        echo "ℹ️ Змін не виявлено — крок apply пропущено"
                    }
                }
            }
        }
    }
}
